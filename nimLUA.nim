# nimLUA
# glue code generator to bind Nim and Lua together using Nim's powerful macro
#
# Copyright (c) 2015 Andri Lim
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
#
#-------------------------------------

import macros, lua, strutils
export lua, macros

type
  bindDesc* = ref object
    node*: NimNode #this is nnkSym or nnkClosedSymChoice node generated by bindSym,
                  # bindXXXImpl will then use getImpl to get the AST body of proc/const/enum/etc implementation
    name*: string  #newname that will be exported, taken from  abc -> "newname", or oldname if no newname supplied
    lhsKind*: NimNodeKind #op '->' lhs kind, it could be nnkIdent or nnkAccQuoted
    rhsKind*: NimNodeKind  #op '->' rhs kind, it could be nnkNone or nnkStrLit or nnkIdent
    isClosure*: bool
    genericParams*: seq[NimNode]

  propDesc = tuple [
    node: string,
    name: string,
    lhsKind: NimNodeKind,
    getter: bool,
    setter: bool
  ]

  proxyDesc* = object
    luaCtx*  : string
    libName* : NimNode
    subject* : NimNode
    bindList*: seq[bindDesc]
    symList* : seq[NimNode]
    propList*: seq[propDesc]

  argDesc = object
    mName, mType, mVal: NimNode

  bindFlag = enum
    nlbUseLib
    nlbRegisterObject
    nlbRegisterClosure
    nlbRegisterGeneric

  bindFlags = set[bindFlag]

  ovProcElem = ref object
    retType: NimNode
    params: seq[argDesc]

  ovProc = ref object
    numArgs: int
    procs: seq[ovProcElem]

  ovList = seq[ovProc]

  ovFlag = enum
    ovfUseObject
    ovfUseRet
    ovfConstructor

  ovFlags = set[ovFlag]

  nlOptions* = enum
    nloNone
    nloDebug
    nloAddMember

#counter that will be used to generate unique intermediate macro name
#and avoid name collision
var
  macroCount {.compileTime.} = 0
  proxyCount {.compileTime.} = 0
  regsCount  {.compileTime.} = 0
  nameList   {.compileTime.} = newSeq[string]()
  outValList {.compileTime.} : seq[string]
  gContext   {.compileTime.} = ""

#inside macro, const bool become nnkIntLit, that's why we need to use
#this trick to test for bool type using 'when internalTestForBOOL(n)'
proc internalTestForBOOL*[T](a: T): bool {.compileTime.} =
  when a is bool: result = true
  else: result = false

proc parseCode(s: string): NimNode {.compileTime.} =
  result = parseStmt(s)
  #echo s

#flatten formal param into seq
proc paramsToArgListBasic(params: NimNode): seq[argDesc] {.compileTime.} =
  var argList = newSeq[argDesc]()
  for i in 1..params.len-1:
    let arg = params[i]
    let mType = arg[arg.len - 2]
    let mVal = arg[arg.len - 1]
    for j in 0..arg.len-3:
      argList.add(argDesc(mName: arg[j], mType: mType, mVal: mVal))
  result = argList

proc paramsToArgList(params: NimNode, subs: seq[NimNode], templateParam: NimNode): seq[argDesc] {.compileTime.} =
  var p = paramsToArgListBasic(params)
  for i in 0..templateParam.len-1:
    for j in 0..p.len-1:
      if $p[j].mType == $templateParam[i]:
        if i < subs.len: p[j].mType = subs[i]
  
  result = p

proc replaceRet(ret: NimNode, subs: seq[NimNode], templateParam: NimNode): NimNode {.compileTime.} =
  for i in 0..templateParam.len-1:
    if $ret == $templateParam[i]:
      if i < subs.len: return subs[i]
  result = ret
  
proc newBindDesc*(node: NimNode, name: string, lhsKind, rhsKind: NimNodeKind,
  isClosure: bool = false, genericParams: seq[NimNode] = @[]): bindDesc {.compileTime.} =
  new(result)
  result.node = node
  result.name = name
  result.lhsKind = lhsKind
  result.rhsKind = rhsKind
  result.isClosure = isClosure
  result.genericParams = genericParams

proc collectGenericParam(p: bindDesc, n: NimNode) {.compileTime.} =
  for i in 1..n.len-1:
    p.genericParams.add n[i]

#split something like 'ident -> "newName"' into tuple
proc splitElem(n: NimNode, opts: bindFlags, proxyName: string): bindDesc {.compileTime.} =
  let
    op  = n[0]
    lhs = n[1]
    rhs = n[2]
    registerObject = nlbRegisterobject in opts
    registerClosure = nlbRegisterClosure in opts
    registerGeneric = nlbRegisterGeneric in opts

  if $op != "->":
    error("wrong operator, must be '->' and not '" & $op & "'")
  if lhs.kind notin {nnkIdent, nnkAccQuoted, nnkCall, nnkBracket, nnkBracketExpr}:
    error("param must be an identifier and not " & $lhs.kind)
  if not registerObject and lhs.kind == nnkCall:
    error("getter/setter not available in bind$1" % [proxyName])
  if not registerClosure and lhs.kind == nnkBracket:
    error("closure not available in bind$1" % [proxyName])
  if not registerGeneric and lhs.kind == nnkBracketExpr:
    error("generic not available in bind$1" % [proxyName])
  if rhs.kind notin {nnkStrLit, nnkIdent}:
    error("alias must be string literal and not " & $rhs.kind)

  if lhs.kind == nnkAccQuoted:
    result = newBindDesc(lhs[0], $rhs, lhs.kind, rhs.kind, false)
  elif lhs.kind == nnkBracket:    
    if lhs[0].kind == nnkAccQuoted:
      result = newBindDesc(lhs[0][0], $rhs, lhs[0].kind, rhs.kind, true)
    else:
      result = newBindDesc(lhs[0], $rhs, lhs.kind, rhs.kind, true)
  elif lhs.kind == nnkBracketExpr:
    if lhs[0].kind == nnkAccQuoted:
      result = newBindDesc(lhs[0][0], $rhs, lhs[0].kind, rhs.kind, false)
    else:
      result = newBindDesc(lhs[0], $rhs, lhs.kind, rhs.kind, false)
    collectGenericParam(result, lhs)  
  else:
    result = newBindDesc(lhs, $rhs, lhs.kind, rhs.kind, false)

#helper proc to flatten nnkStmtList
proc unwindList(arg: NimNode, elemList: var seq[bindDesc], opts: bindFlags, proxyName: string) {.compileTime.} =
  let
    registerObject = nlbRegisterobject in opts
    registerClosure = nlbRegisterClosure in opts
    registerGeneric = nlbRegisterGeneric in opts

  for i in 0..arg.len-1:
    let n = arg[i]
    case n.kind:
    of nnkIdent:
      let elem = newBindDesc(n, $n, n.kind, nnkNone)
      elemList.add elem
    of nnkAccQuoted:
      let elem = newBindDesc(n[0], "`" & $n[0] & "`", n.kind, nnkNone)
      elemList.add elem
    of nnkInfix:
      elemList.add splitElem(n, opts, proxyName)
    of nnkCall:
      if not registerObject:
        error("getter/setter not available in bind$1" % [proxyName])
      let elem = newBindDesc(n, $n[0], n.kind, nnkNone)
      elemList.add elem
    of nnkBracket:
      if not registerClosure:
        error("closure not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone, true)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone, true)
      elemList.add elem
    of nnkBracketExpr:
      if not registerGeneric:
        error("generic not available in bind$1" % [proxyName])      
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone, false)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone, false)
      collectGenericParam(elem, n)
      elemList.add elem
    else:
      error("wrong param type: \n" & n.treeRepr)

proc checkDuplicate(list: seq[bindDesc]): string {.compileTime.} =
  var checked = newSeq[bindDesc]()
  for k in list:
    if checked.contains(k):
      return $k.node
    else:
      checked.add k
  result = ""

#here is the factory of second level macro that will be expanded to utilize bindSym
proc genProxyMacro(arg: NimNode, opts: bindFlags, proxyName: string): NimNode {.compileTime.} =
  let
    useLib = nlbUseLib in opts
    registerObject = nlbRegisterobject in opts
    registerClosure = nlbRegisterClosure in opts
    registerGeneric = nlbRegisterGeneric in opts

  var
    luaCtx   = ""
    libName  = ""
    libKind: NimNodeKind
    objectName = ""
    objectNewName = ""
    elemList = newSeq[bindDesc]()
    propList = newSeq[propDesc]()

  for i in 0..arg.len-1:
    let n = arg[i]
    case n.kind
    of nnkSym:
      if i == 0: luaCtx = $n
      else:
        error("param " & $i & " must be an identifier, not symbol\n" & arg.treeRepr)
    of nnkStrLit:
      if i == 1 and useLib:
        libName = n.strVal
        libKind = n.kind
      else:
        error("param " & $i & " must be an identifier, not string literal\n" & toStrLit(callSite()).treeRepr)
    of nnkIdent:
      if i == 1 and $n == "GLOBAL" and useLib:
        libName = $n
        libKind = n.kind
      elif i == 1 and registerObject:
        objectName = $n
        objectNewName = $n
      else:
        let elem = newBindDesc(n, $n, n.kind, nnkNone)
        elemList.add elem
    of nnkAccQuoted:
      let elem = newBindDesc(n[0], "`" & $n[0] & "`", n.kind, nnkNone)
      elemList.add elem
    of nnkInfix:
      if registerObject and i == 1:
        let k = splitElem(n, opts, proxyName)
        objectName = $k.node
        objectNewName = k.name
      else:
        elemList.add splitElem(n, opts, proxyName)
    of nnkCall:
      if not registerObject:
        error("getter/setter not available in bind$1" % [proxyName])
      let elem = newBindDesc(n, $n[0], n.kind, nnkNone)
      elemList.add elem
    of nnkBracket:
      if not registerClosure:
        error("closure not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone, true)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone, true)
      elemList.add elem
    of nnkBracketExpr:
      if not registerGeneric:
        error("generic not available in bind$1" % [proxyName])
      let elem = if n[0].kind == nnkAccQuoted:
          newBindDesc(n[0][0], "`" & $n[0][0] & "`", n[0].kind, nnkNone, false)
        else:
          newBindDesc(n[0], $n[0], n.kind, nnkNone, false)
      collectGenericParam(elem, n)
      elemList.add elem
    of nnkStmtList:
      unwindList(n, elemList, opts, proxyName)
    else:
      error("wrong param type\n" & n.treeRepr)

  if luaCtx == "":
    error("need luaState as first param")

  let dup = elemList.checkDuplicate()
  if dup != "":
    error("bind$1 detected duplicated entries: $2" % [proxyName, dup])

  #generate intermediate macro to utilize bindSym that can only accept string literal
  let macroName = "NLB$1$2" % [proxyName, $macroCount]
  var nlb = "macro " & macroName & "(): stmt =\n"
  nlb.add "  var ctx: proxyDesc\n"
  nlb.add "  ctx.luaCtx = \"$1\"\n" % [luaCtx]
  if registerObject:
    nlb.add "  ctx.subject = bindSym\"$1\"\n" % [objectName]
  else:
    nlb.add "  ctx.subject = newEmptyNode()\n"

  var numElem = 0
  for k in elemList:
    if k.node.kind in {nnkAccQuoted, nnkIdent}:
      inc numElem
    elif k.node.kind == nnkCall:
      var v = if k.node[0].kind == nnkAccQuoted:
          (node: $k.node[0][0], name: "`" & $k.node[0][0] & "`", lhsKind: k.node[0].kind, getter: false, setter: false)
        else:
          (node: $k.node[0], name: $k.node[0], lhsKind: k.node[0].kind, getter: false, setter: false)

      if k.rhsKind in {nnkStrLit, nnkIdent}: v.name = k.name

      for i in 1..k.node.len-1:
        let n = k.node[i]
        if n.kind != nnkIdent: error(v.node & ": getter/setter attribut must be identifier")
        if $n == "get": v.getter = true
        elif $n == "set": v.setter = true
        else: error(v.node & ": getter/setter attribute must be 'get' and/or 'set'")
      if v.getter == false and v.setter == false: error(v.node & ": getter/setter attribute must be present")
      propList.add v
    else:
      error("unexpected node kind: " & $k.node.kind)

  if numElem > 0:
    nlb.add "  ctx.bindList = @[\n"
    var i = 0
    for k in elemList:
      let comma = if i < numElem: "," else: ""
      if k.node.kind in {nnkAccQuoted, nnkIdent}:
        var gp = ""
        if k.genericParams.len > 0:
          gp.add "@["
          var ii = 0
          for x in k.genericParams:
            let cma = if ii < k.genericParams.len-1: "," else: ""
            gp.add "bindSym\"$1\"$2" % [$x, cma]
            inc ii
          gp.add "]"
        else:
          gp.add "newSeq[NimNode]()"
        nlb.add "    newBindDesc(bindSym\"$1\", \"$2\", $3, $4, $5, $6)$7\n" %
          [$k.node, k.name, $k.lhsKind, $k.rhsKind, $k.isClosure, gp, comma]
        inc i
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.bindList = @[]\n"

  if propList.len > 0:
    nlb.add "  ctx.propList = @[\n"
    var ii = 0
    for k in propList:
      let comma = if ii < propList.len-1: "," else: ""
      nlb.add "    (\"$1\", \"$2\", $3, $4, $5)$6\n" %
        [k.node, k.name, $k.lhsKind, $k.getter, $k.setter, comma]
      inc ii
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.propList = @[]\n"

  if libKind == nnkStrLit:
    nlb.add "  ctx.libName = newStrLitNode(\"$1\")\n" % [libName]
  elif libKind == nnkIdent:
    nlb.add "  ctx.libName = newIdentNode(!\"$1\")\n" % [libName]
  elif registerObject:
    nlb.add "  ctx.libName = newIdentNode(!\"$1\")\n" % [objectNewName]
  else:
    nlb.add "  ctx.libName = newEmptyNode()\n"

  nlb.add "  result = proxyMixer(ctx, \"$1\")\n" % [proxyName]
  nlb.add macroName & "()\n"

  result = parseCode(nlb)
  inc macroCount

#both normal ident and backticks quoted ident converted to string
proc getAccQuotedName(n: NimNode, kind: NimNodeKind): string {.compileTime.} =
  let name = if n.kind == nnkClosedSymChoice: $n[0] else: $n
  if kind == nnkAccQuoted: result = "`" & name & "`" else: result = name

proc ignoreGenerics(ids: var seq[string], id: string, generics: NimNode) {.compileTime.} =
  var found = false
  if generics.kind == nnkGenericParams:
    for k in generics:
      if $k == id:
        found = true
        break
  if not found: ids.add id

proc collectSym(ids: var seq[string], arg: NimNode) {.compileTime.} =
  if arg.kind == nnkProcDef:
    let generics = arg[2]
    let params  = arg[3]
    let retType = params[0]
    let argList = paramsToArgListBasic(params)
    if retType.kind == nnkIdent: ignoreGenerics(ids, $retType, generics)
    for k in argList:
      if k.mType.kind == nnkIdent: ignoreGenerics(ids, $k.mType, generics)
      if k.mVal.kind == nnkIdent: ignoreGenerics(ids, $k.mVal, generics)

proc checkProp(subject: NimNode, prop: string): bool {.compileTime.} =
  let recList = subject[2][2]
  for n in recList:
    if n[0].kind == nnkIdent:
      if $n[0] == prop: return true
    elif n[0].kind == nnkPostfix:
      if $n[0][1] == prop: return true
    else:
      error("unknown prop construct")
  result = false

proc checkObject(subject: NimNode): bool {.compileTime.} =
  result = subject[2].kind in {nnkObjectTy, nnkRefTy}

proc proxyMixer*(ctx: proxyDesc, proxyName: string): NimNode {.compileTime.} =
  var ids = newSeq[string]()

  for n in ctx.bindList:
    if n.node.kind == nnkSym:
      let im = getImpl(n.node.symbol)
      collectSym(ids, im)
    else:
      for s in children(n.node):
        let im = getImpl(s.symbol)
        collectSym(ids, im)

  let macroName = "NLB$1$2" % [proxyName, $macroCount]
  var nlb = "macro " & macroName & "(): stmt =\n"
  nlb.add "  var ctx: proxyDesc\n"
  nlb.add "  ctx.luaCtx = \"$1\"\n" % [ctx.luaCtx]
  if ctx.subject.kind == nnkSym:
    let subject = getImpl(ctx.subject.symbol)
    if not checkObject(subject):
      error($ctx.subject & ": not an object")
    nlb.add "  ctx.subject = bindSym\"$1\"\n" % [$ctx.subject]
  else:
    nlb.add "  ctx.subject = newEmptyNode()\n"

  if ctx.bindList.len > 0:
    nlb.add "  ctx.bindList = @[\n"
    var i = 0
    for k in ctx.bindList:
      var gp = ""
      if k.genericParams.len > 0:
        gp.add "@["
        var ii = 0
        for x in k.genericParams:
          let cma = if ii < k.genericParams.len-1: "," else: ""
          gp.add "bindSym\"$1\"$2" % [$x, cma]
          inc ii
        gp.add "]"
      else:
        gp.add "newSeq[NimNode]()"
          
      let comma = if i < ctx.bindList.len-1: "," else: ""
      nlb.add "    newBindDesc(bindSym\"$1\", \"$2\", $3, $4, $5, $6)$7\n" %
        [$k.node, k.name, $k.lhsKind, $k.rhsKind, $k.isClosure, gp, comma]
      inc i
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.bindList = @[]\n"

  if ctx.propList.len > 0:
    nlb.add "  ctx.propList = @[\n"
    var ii = 0
    let subject = getImpl(ctx.subject.symbol)
    for k in ctx.propList:
      if not checkProp(subject, k.node):
        error($ctx.subject & ": don't have properties " & k.name)
      let comma = if ii < ctx.propList.len-1: "," else: ""
      nlb.add "    (\"$1\", \"$2\", $3, $4, $5)$6\n" %
        [k.node, k.name, $k.lhsKind, $k.getter, $k.setter, comma]
      inc ii
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.propList = @[]\n"

  if ids.len > 0:
    nlb.add "  ctx.symList = @[\n"
    var i = 0
    for k in ids:
      let comma = if i < ids.len-1: "," else: ""
      nlb.add "    bindSym\"$1\"$2\n" % [k, comma]
      inc i
    nlb.add "  ]\n"
  else:
    nlb.add "  ctx.symList = @[]\n"

  if ctx.libName.kind == nnkStrLit:
    nlb.add "  ctx.libName = newStrLitNode(\"$1\")\n" % [$ctx.libName]
  elif ctx.libName.kind == nnkIdent:
    nlb.add "  ctx.libName = newIdentNode(!\"$1\")\n" % [$ctx.libName]
  else:
    nlb.add "  ctx.libName = newEmptyNode()\n"

  nlb.add "  result = bind$1Impl(ctx)\n" % [proxyName]
  nlb.add macroName & "()\n"

  result = parseCode(nlb)
  inc macroCount

#proc params and return type
proc newProcElem(retType: NimNode, params: seq[argDesc]): ovProcElem {.compileTime.} =
  result = new(ovProcElem)
  result.retType = retType
  result.params = params

#list of overloaded proc
proc newOvProc(retType: NimNode, params: seq[argDesc]): ovProc {.compileTime.} =
  var ovp = new(ovProc)
  ovp.numArgs = params.len
  ovp.procs = newSeq[ovProcElem]()
  ovp.procs.add newProcElem(retType, params)
  result = ovp

#add overloaded proc into ovList
proc addOvProc(ovl: var ovList, retType: NimNode, params: seq[argDesc]) {.compileTime.} =
  var found = false
  for k in ovl:
    if k.numArgs == params.len:
      k.procs.add newProcElem(retType, params)
      found = true
      break

  if not found:
    ovl.add newOvProc(retType, params)

proc isRefType(s: NimNode): bool {.compileTime.} =
  let n = getImpl(s.symbol)
  if n.kind != nnkTypeDef: return false
  if n[2].kind != nnkRefTy: return false
  result = true

proc hasName(name: string): bool {.compileTime.} =
  for n in nameList:
    if n == name: return true
  result = false

proc setName(name: string) {.compileTime.} =
  nameList.add(name)

proc registerObject(subject: NimNode): string {.compileTime.} =
  let name = $subject
  let prefixedName = "nlobj" & name
  for i in 0..nameList.high:
    if nameList[i] == prefixedName:
      return name & $i

  let subjectName = name & $nameList.len
  nameList.add prefixedName
  var glue = "const\n"
  glue.add "  luaL_$1 = \"luaL_$1\"\n" % [subjectName]
  glue.add "type\n"
  glue.add "  luaL_$1Proxy = object\n" % [subjectName]
  glue.add "    ud: $1\n" % [name]
  gContext.add glue
  result = subjectName

proc checkUD(s, n: string): string {.compileTime.} =
  result = "cast[ptr luaL_$1Proxy](L.checkUData($2.cint, luaL_$1))\n" % [s, n]

proc newUD(s: string): string {.compileTime.} =
  result = "cast[ptr luaL_$1Proxy](L.newUserData(sizeof(luaL_$1Proxy)))\n" % [s]

proc addMemberCap(SL, libName: string, argLen: int): string {.compileTime.} =
  when true:
    var glue = ""
    glue.add "$1.getGlobal(\"$2\")\n" % [SL, libName]
    glue.add "if not $1.isTable(-1):\n" % [SL]
    glue.add "  $1.pop(1)\n" % [SL]
    glue.add "  $1.createTable(0.cint, $2.cint)\n" % [SL, $(argLen)]
    return glue
  else:
    result = "$1.createTable(0.cint, $2.cint)\n" % [SL, $(argLen)]

proc nimLuaPanic(L: PState): cint {.cdecl.} =
  echo "panic"
  echo L.toString(-1)
  L.pop(1)
  return 1

#call this before you use this library
proc newNimLua*(readOnlyEnum = false): PState =
  var L = newState()
  L.openLibs
  discard L.atPanic(nimLuaPanic)

  let roEnum = """
function readonlytable(table)
   return setmetatable({}, {
     __index = table,
     __newindex = function(table, key, value) error("Attempt to modify read-only table") end,
     __metatable = false
   });
end
"""
  let rwEnum = """
function readonlytable(table)
   return table
end

"""

  discard L.doString(if readOnlyEnum: roEnum else: rwEnum)
  result = L

# -------------------------------------------------------------------------
# --------------------------------- bindEnum ------------------------------
# -------------------------------------------------------------------------

proc bindEnumScoped(SL: string, s: NimNode, scopeName: string, kind: NimNodeKind): string {.compileTime.} =
  let x = getImpl(s.symbol)
  var err = false
  if x.kind != nnkTypeDef: err = true
  if x[0].kind != nnkSym: err = true
  if x[2].kind != nnkEnumTy: err = true
  if err:
    error("bindEnum: incorrect enum definition")

  let
    numEnum = x[2].len - 1
    enumName = if kind == nnkAccQuoted: "`" & $x[0] & "`" else: $x[0]

  var glue = ""
  glue.add "$1.getGlobal(\"readonlytable\")\n" % [SL]
  glue.add addMemberCap(SL, scopeName, numEnum)

  for i in 1..numEnum:
    let
      n = x[2][i]
      sym = if n.kind == nnkAccQuoted: "`" & $n[0] & "`" else: $n
    glue.add "discard $1.pushlString(\"$2\", $3)\n" % [SL, sym, $sym.len]
    glue.add "when compiles($1):\n" % [sym]
    glue.add "  $1.pushInteger(lua_Integer($2))\n" % [SL, sym]
    glue.add "else:\n"
    glue.add "  $1.pushInteger(lua_Integer($2.$3))\n" % [SL, enumName, sym]
    glue.add "$1.setTable(-3)\n" % [SL]

  glue.add "discard $1.pcall(1, 1, 0)\n" % [SL]
  glue.add "$1.setGlobal(\"$2\")\n" % [SL, scopeName]
  result = glue

proc bindEnumGlobal(SL: string, s: NimNode, kind: NimNodeKind): string {.compileTime.} =
  let x = getImpl(s.symbol)
  var err = false
  if x.kind != nnkTypeDef: err = true
  if x[0].kind != nnkSym: err = true
  if x[2].kind != nnkEnumTy: err = true
  if err:
    error("bindEnum: incorrect enum definition")

  let
    numEnum = x[2].len - 1
    enumName = if kind == nnkAccQuoted: "`" & $x[0] & "`" else: $x[0]

  var glue = ""
  for i in 1..numEnum:
    let
      n = x[2][i]
      sym = if n.kind == nnkAccQuoted: "`" & $n[0] & "`" else: $n
    glue.add "when compiles($1):\n" % [sym]
    glue.add "  $1.pushInteger(lua_Integer($2))\n" % [SL, sym]
    glue.add "else:\n"
    glue.add "  $1.pushInteger(lua_Integer($2.$3))\n" % [SL, enumName, sym]
    glue.add "$1.setGlobal(\"$2\")\n" % [SL, sym]

  result = glue

#this proc need to be exported because intermediate macro call this proc from
#callsite module
proc bindEnumImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    arg = ctx.bindList

  var glue = ""
  for i in 0..arg.len-1:
    let n = arg[i]
    if n.name == "GLOBAL" and n.rhsKind == nnkIdent: glue.add bindEnumGlobal(SL, n.node, n.lhsKind)
    else: glue.add bindEnumScoped(SL, n.node, n.name, n.lhsKind)

  result = parseCode(glue)

macro bindEnum*(arg: varargs[untyped]): stmt =
  result = genProxyMacro(arg, {}, "Enum")

# -------------------------------------------------------------------------
# ----------------------------- bindFunction ------------------------------
# -------------------------------------------------------------------------

#runtime type check helper for string
proc checkNimString*(L: PState, idx: cint): string =
  if L.isString(idx) != 0: result = L.toString(idx)
  else:
    discard L.error("expected string arg")
    result = ""

#runtime type check helper for bool
proc checkNimBool*(L: PState, idx: cint): bool =
  if L.isBoolean(idx):
    result = if L.toBoolean(idx) == 0: false else: true
  else:
    discard L.error("expected bool arg")
    result = false

let
  intTypes {.compileTime.} = ["int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64"]
  floatTypes {.compileTime.} = ["float", "float32", "float64"]

proc constructBasicArg(mType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = $mType
  for c in intTypes:
    if c == argType:
      return "L.checkInteger(" & $i & ")." & c & "\n"

  for c in floatTypes:
    if c == argType:
      return "L.checkNumber(" & $i & ")." & c & "\n"

  if argType == "string":
    return "L.checkNimString(" & $i & ")\n"

  if argType == "cstring":
    return "L.checkString(" & $i & ")\n"

  if argType == "bool":
    return "L.checkNimBool(" & $i & ")\n"

  if argType == "char":
    return "L.checkInteger(" & $i & ").chr\n"

  if argType == "pointer":
    return "L.toUserData(" & $i & ")\n"

  result = ""

proc constructBasicRet(mType: NimNode, arg, indent, procName: string): string {.compileTime.} =
  let retType = $mType
  for c in intTypes:
    if c == retType:
      return indent & "L.pushInteger(lua_Integer(" & arg & "))\n"

  for c in floatTypes:
    if c == retType:
      return indent & "L.pushNumber(lua_Number(" & arg & "))\n"

  if retType == "string":
    return indent & "discard L.pushLiteral(" & arg & ")\n"

  if retType == "cstring":
    return indent & "discard L.pushString(" & arg & ")\n"

  if retType == "bool":
    return indent & "L.pushBoolean(" & arg & ".cint)\n"

  if retType == "char":
    return indent & "L.pushInteger(lua_Integer(" & arg & "))\n"

  if retType == "pointer":
    return indent & "L.pushLightUserData(" & arg & ")\n"

  result = ""

proc constructArg(ctx: proxyDesc, mType: NimNode, i: int, procName: string): string {.compileTime.}

proc argAttr(mType: NimNode): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType.symbol)
    if nType.kind == nnkTypeDef and nType[2].kind in {nnkObjectTy, nnkRefTy}:
      return ".ud"

    if nType.kind == nnkTypeDef and nType[2].kind in {nnkDistinctTy, nnkEnumTy}:
      return "." & $nType[0]

  if mType.kind == nnkVarTy:
    if getType(mType[0]).kind in {nnkObjectTy, nnkRefTy}:
      return ".ud"

  result = ""

proc stackDump*(L: PState) =
  let top = L.getTop()
  echo "total in stack ", top
  for i in 1..top:
    #repeat for each level
    let t = L.luatype(i)
    case t
    of LUA_TSTRING:
      echo "string: '$1'" % L.toString(i)
    of LUA_TBOOLEAN:
      echo "boolean $1" % [if L.toBoolean(i) == 1: "true" else: "false"]
    of LUA_TNUMBER:
      echo "number: $1" % [$(L.toNumber(i).int)]
    else:
      echo "$1" % [$L.typeName(t)]

proc registerArrayCheck(ctx: proxyDesc, s: NimNode, lo, hi: int, procName: string): string {.compileTime.} =
  let name = "checkArray$1$2$3" % [$s, $lo, $hi]
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): array[$2..$3, $4] =\n" % [name, $lo, $hi, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = min(L.llen(idx.cint), result.len)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName)
    glue.add "    result[i+$1] = tmp$2\n" % [$lo, argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue
  result = name

proc registerArrayCheck(ctx: proxyDesc, s: NimNode, hi: int, procName: string): string {.compileTime.} =
  let name = "checkArray$1$2" % [$s, $hi]
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): array[$2, $3] =\n" % [name, $hi, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = min(L.llen(idx.cint), result.len)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName)
    glue.add "    result[i] = tmp$1\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc registerArrayCheck(ctx: proxyDesc, s: NimNode, id: string, procName: string): string {.compileTime.} =
  let name = "checkArray$1$2" % [$s, id]
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): array[$2, $3] =\n" % [name, id, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = min(L.llen(idx.cint), result.len)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName)
    glue.add "    result[i] = tmp$1\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc genArrayArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  var lo, hi, mode: int

  if nType[1].kind == nnkInfix:
    lo = int(nType[1][1].intVal)
    hi = int(nType[1][2].intVal)
    mode = 1
  elif nType[1].kind == nnkIntLit:
    lo = 0
    hi = int(nType[1].intVal)
    mode = 2
  elif nType[1].kind == nnkIdent:
    mode = 3
  else:
    error(procName & ": unknown array param type: " & nType.treeRepr)

  let argType = nType[2]

  let res = constructArg(ctx, argType, -1, procName)
  let checkArray = if mode == 1:
      registerArrayCheck(ctx, argType, lo, hi, procName)
    elif mode == 2:
      registerArrayCheck(ctx, argType, hi, procName)
    else:
      registerArrayCheck(ctx, argType, $nType[1], procName)

  var glue = "L.$1($2)\n" % [checkArray, $i]
  if res != "": return glue

  error(procName & ": unknown array param type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc registerSetCheck(ctx: proxyDesc, s: NimNode, procName: string): string {.compileTime.} =
  let name = "checkSet$1" % [$s]
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): set[$2] =\n" % [name, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = L.llen(idx.cint)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName)
    glue.add "    result.incl(tmp$1)\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc genSetArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = nType[1]
  let res = constructArg(ctx, argType, -1, procName)
  let checkSet = registerSetCheck(ctx, argType, procName)
  var glue = "L.$1($2)\n" % [checkSet, $i]
  if res != "": return glue
  error(procName & ": unknown set param type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc registerSequenceCheck(ctx: proxyDesc, s: NimNode, procName: string): string {.compileTime.} =
  let name = "checkSequence$1" % [$s]
  if not hasName(name):
    setName(name)
    var glue = "proc $1(L: PState, idx: int): seq[$2] =\n" % [name, $s]
    glue.add "  L.checkType(idx.cint, LUA_TTABLE)\n"
    glue.add "  let len = L.llen(idx.cint)\n"
    glue.add "  L.pushNil()\n"
    glue.add "  result = newSeq[$1](len)\n" % [$s]
    glue.add "  var i = 0\n"
    glue.add "  while L.next(idx.cint) != 0:\n"
    glue.add "    let tmp = " & constructArg(ctx, s, -1, procName)
    glue.add "    result[i] = tmp$1\n" % [argAttr(s)]
    glue.add "    L.pop(1.cint)\n"
    glue.add "    inc i\n"
    glue.add "    if i >= len: break\n"
    gContext.add glue

  result = name

proc genSequenceArg(ctx: proxyDesc, nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = nType[1]
  let res = constructArg(ctx, argType, -1, procName)
  let checkSeq = registerSequenceCheck(ctx, argType, procName)
  var glue = "L.$1($2)\n" % [checkSeq, $i]
  if res != "": return glue
  error(procName & ": unknown seq param type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genPtrArg(nType: NimNode, i: int, procName: string): string {.compileTime.} =
  let argType = $nType[0].toStrLit
  result = "cast[ptr $1](L.toUserData($2.cint))\n" % [argType, $i]

proc genRangeArg(nType: NimNode, i: int, procName: string): string {.compileTime.} =
  result = "L.checkInteger($1.cint).int\n" % [$i]

proc constructComplexArg(ctx: proxyDesc, mType: NimNode, i: int, procName: string): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType.symbol)[2]
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      return checkUD(registerObject(mType), $i)

    if nType.kind == nnkDistinctTy:
      return constructArg(ctx, nType[0], i, procName)

    if nType.kind == nnkEnumTy:
      return constructArg(ctx, bindSym"int", i, procName)

    if nType.kind == nnkBracketExpr:
      if $nType[0] == "array":
        return genArrayArg(ctx, nType, i, procName)
      if $nType[0] == "set":
        return genSetArg(ctx, nType, i, procName)
      if $nType[0] == "seq":
        return genSequenceArg(ctx, nType, i, procName)
      if $nType[0] == "range":
        return genRangeArg(nType, i, procName)

    if nType.kind == nnkPtrTy:
      return genPtrArg(nType, i, procName)

    if nType.kind == nnkSym:
      if $nType == "pointer":
        return "L.toUserData($1.cint)\n" % [$i]

  if mType.kind == nnkBracketExpr:
    if $mType[0] == "array":
      return genArrayArg(ctx, mType, i, procName)
    if $mType[0] == "set":
      return genSetArg(ctx, mType, i, procName)
    if $mType[0] == "seq":
      return genSequenceArg(ctx, mType, i, procName)
    if $mType[0] == "range":
      return genRangeArg(mType, i, procName)

  if mType.kind == nnkPtrTy:
    return genPtrArg(mType, i, procName)

  if mType.kind == nnkVarTy:
    let nType = getType(mType[0])
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      return checkUD(registerObject(mType[0]), $i)
    if nType.kind == nnkSym:
      outValList.add constructBasicRet(nType, "arg" & $(i-1), "", procName)
      return constructBasicArg(nType, i, procName)

  if mType.kind == nnkEnumTy:
    return "L.checkInteger($1.cint).$2\n" % [$i, $mType[0]]

  error(procName & ": unknown param type: " & $mType.kind & "\n" & mType.treeRepr)
  result = ""

proc constructRet(retType: NimNode, procCall, indent, procName: string): string {.compileTime.}

proc genArrayRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  var lo, hi, mode: int

  if nType[1].kind == nnkInfix:
    lo = int(nType[1][1].intVal)
    hi = int(nType[1][2].intVal)
    mode = 1
  elif nType[1].kind == nnkIntLit:
    lo = 0
    hi = int(nType[1].intVal)
    mode = 2
  elif nType[1].kind == nnkIdent:
    mode = 3
  else:
    error(procName & ": unknown array ret type: " & nType.treeRepr)

  let retType = nType[2]

  var glue = indent & "L.createTable($1+1, 0)\n" % [$hi]
  glue.add indent & "let arrTmp = $1\n" % [procCall]
  var res = ""

  if mode == 1:
    glue.add indent & "for i in $1..$2:\n" % [$lo, $hi]
    glue.add indent & "  L.pushInteger(i-$1+1)\n" % [$lo]
    res = constructRet(retType, "arrTmp[i-$1]" % [$lo], indent & "  ", procName)
    glue.add res
  elif mode == 2:
    glue.add indent & "for i in $1..$2-1:\n" % [$lo, $hi]
    glue.add indent & "  L.pushInteger(i-$1+1)\n" % [$lo]
    res = constructRet(retType, "arrTmp[i-$1]" % [$lo], indent & "  ", procName)
    glue.add res
  else:
    glue.add indent & "for i in 0..$1-1:\n" % [$nType[1]]
    glue.add indent & "  L.pushInteger(i+1)\n"
    res = constructRet(retType, "arrTmp[i]", indent & "  ", procName)
    glue.add res

  glue.add indent & "  L.setTable(-3)\n"

  if res != "": return glue

  error(procName & ": unknown array ret type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genSetRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  let retType = nType[1]
  var glue = ""

  glue.add indent & "let setTmp = $1\n" % [procCall]
  glue.add indent & "L.createTable((card(setTmp)+1).cint, 0.cint)\n"
  glue.add indent & "var setIdx = 1\n"

  var res = ""
  glue.add indent & "for k in setTmp:\n"
  glue.add indent & "  L.pushInteger(setIdx)\n"
  res = constructRet(retType, "k", indent & "  ", procName)
  glue.add res
  glue.add indent & "  L.setTable(-3)\n"
  glue.add indent & "  inc setIdx\n"
  if res != "": return glue

  error(procName & ": unknown set ret type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc genSequenceRet(nType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  let retType = nType[1]
  var glue = ""

  glue.add indent & "let seqTmp = $1\n" % [procCall]
  glue.add indent & "L.createTable((seqTmp.len+1).cint, 0.cint)\n"
  glue.add indent & "var seqIdx = 1\n"

  var res = ""
  glue.add indent & "for k in seqTmp:\n"
  glue.add indent & "  L.pushInteger(seqIdx)\n"
  res = constructRet(retType, "k", indent & "  ", procName)
  glue.add res
  glue.add indent & "  L.setTable(-3)\n"
  glue.add indent & "  inc seqIdx\n"
  if res != "": return glue

  error(procName & ": unknown seq ret type: " & $nType.kind & "\n" & nType.treeRepr)
  result = ""

proc constructComplexRet(mType: NimNode, procCall, indent, procName: string): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType.symbol)[2]

    if nType.kind == nnkBracketExpr:
      if $nType[0] == "array":
        return genArrayRet(nType, procCall, indent, procName)
      if $nType[0] == "set":
        return genSetRet(nType, procCall, indent, procName)
      if $nType[0] == "seq":
        return genSequenceRet(nType, procCall, indent, procName)
      if $nType[0] == "range":
        return indent & "L.pushInteger(lua_Integer(" & procCall & "))\n"

    if nType.kind in {nnkObjectTy, nnkRefTy}:
      let subjectName = registerObject(mType)
      var glue = indent & "var proxyret = " & newUD(subjectName)
      glue.add indent & "proxyret.ud = $1\n" % [procCall]
      if isRefType(mType): glue.add indent & "GC_ref(proxyret.ud)\n"
      glue.add indent & "L.getMetatable(luaL_$1)\n" % [subjectName]
      glue.add indent & "discard L.setMetatable(-2)\n"
      return glue

    if nType.kind == nnkDistinctTy:
      return constructRet(nType[0], procCall, indent, procName)

    if nType.kind == nnkEnumTy:
      return indent & "L.pushInteger(lua_Integer(" & procCall & "))\n"

    if nType.kind == nnkPtrTy:
      return indent & "L.pushLightUserData(cast[pointer](" & procCall & "))\n"

    if nType.kind == nnkSym:
      if $nType == "pointer":
        return indent & "L.pushLightUserData(" & procCall & ")\n"

  if mType.kind == nnkPtrTy:
    return indent & "L.pushLightUserData(cast[pointer](" & procCall & "))\n"

  if mType.kind == nnkBracketExpr:
    if $mType[0] == "array":
      return genArrayRet(mType, procCall, indent, procName)
    if $mType[0] == "set":
      return genSetRet(mType, procCall, indent, procName)
    if $mType[0] == "seq":
      return genSequenceRet(mType, procCall, indent, procName)
    if $mType[0] == "range":
      return indent & "L.pushInteger(lua_Integer(" & procCall & "))\n"

  if mType.kind == nnkVarTy:
    if getType(mType[0]).kind in {nnkObjectTy, nnkRefTy}:
      let subjectName = registerObject(mType)
      var glue = indent & "var proxy = " & newUD(subjectName)
      glue.add indent & "proxy.ud = $1\n" % [procCall]
      glue.add indent & "L.getMetatable(luaL_$1)\n" % [subjectName]
      glue.add indent & "discard L.setMetatable(-2)\n"
      return glue

  error(procName & ": unknown ret type: " & $mType.kind & "\n" & mType.treeRepr)
  result = ""

proc constructArg(ctx: proxyDesc, mType: NimNode, i: int, procName: string): string =
  case mType.kind:
  of nnkSym:
    result = constructBasicArg(mType, i, procName)
    if result == "": result = constructComplexArg(ctx, mType, i, procName)
  else:
    result = constructComplexArg(ctx, mType, i, procName)

proc constructRet(retType: NimNode, procCall, indent, procName: string): string =
  case retType.kind:
  of nnkSym:
    result = constructBasicRet(retType, procCall, indent, procName)
    if result == "": result = constructComplexRet(retType, procCall, indent, procName)
  else:
    result = constructComplexRet(retType, procCall, indent, procName)

proc findSymbol(ctx: proxyDesc, s: NimNode): NimNode =
  for k in ctx.symList:
    if $s == $k: return getType(k)
  result = newEmptyNode()

proc genOvCallSingle(ctx: proxyDesc, ovp: ovProcElem, procName, indent: string, flags: ovFlags): string {.compileTime.} =
  var glueParam = ""
  var glue = ""
  let start = if ovfUseObject in flags: 1 else: 0
  outValList = @[]

  for i in start..ovp.params.len-1:
    let param = ovp.params[i]
    let pType = if param.mType.kind != nnkEmpty: param.mType else: findSymbol(ctx, param.mVal)
    glue.add indent & "  var arg" & $i & " = " & constructArg(ctx, pType, i + 1, procName)
    glueParam.add "arg" & $i & argAttr(param.mType)
    if i < ovp.params.len-1: glueParam.add ", "

  if ovfConstructor in flags:
    let procCall = procName & "(" & glueParam & ")"
    glue.add indent & "  proxy.ud = " & procCall & "\n"
  else:
    let procCall = if ovfUseObject in flags:
        "proxy.ud.$1($2)" % [procName, glueParam]
      else:
        procName & "(" & glueParam & ")"

    if ovfUseRet in flags:
      var numRet = 0
      if ovp.retType.kind == nnkEmpty:
        glue.add indent & "  " & procCall & "\n"
      else:
        glue.add constructRet(ovp.retType, procCall, indent & "  ", procName)
        numRet = 1

      inc(numRet, outValList.len)
      for s in outValList:
        glue.add "$1  $2" % [indent, s]

      glue.add "$1  return $2\n" % [indent, $numRet]
  result = glue

proc bindSingleFunction(ctx: proxyDesc, gp: seq[NimNode], n: NimNode, glueProc, procName: string): string {.compileTime.} =
  if n.kind != nnkProcDef:
    error("bindFunction: " & procName & " is not a proc")

  let params = n[3]
  let retType = replaceRet(params[0], gp, n[2])
  let argList = paramsToArgList(params, gp, n[2])

  var glue = "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfUseRet})

  result = glue

proc genBasicCheck(mType: NimNode, i: int, procNane: string): string {.compileTime.} =
  let argType = $mType
  for c in intTypes:
    if c == argType:
      return "(L.isInteger(" & $i & ") == 1)"

  for c in floatTypes:
    if c == argType:
      return "(L.isNumber(" & $i & ") == 1)"

  if argType == "string":
    return "(L.isString(" & $i & ") == 1)"

  if argType == "cstring":
    return "(L.isString(" & $i & ") == 1)"

  if argType == "bool":
    return "L.isBoolean(" & $i & ")"

  if argType == "char":
    return "(L.isInteger(" & $i & ") == 1)"

  if argType == "pointer":
    return "(L.isUserData(" & $i & ") == 1)"

  result = ""

proc genCheckType(mType: NimNode, i: int, procName: string): string {.compileTime.}

proc genComplexCheck(mType: NimNode, i: int, procName: string): string {.compileTime.} =
  if mType.kind == nnkSym:
    let nType = getImpl(mType.symbol)[2]
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      return "(L.isUserData(" & $i & ") == 1)"

    if nType.kind == nnkDistinctTy:
      return genCheckType(nType, i, procName)

    if nType.kind == nnkEnumTy:
      return "(L.isInteger(" & $i & ") == 1)"

    if nType.kind == nnkBracketExpr:
      if $nType[0] == "array":
        return "L.isTable(" & $i & ")"
      if $nType[0] == "set":
        return "L.isTable(" & $i & ")"
      if $nType[0] == "seq":
        return "L.isTable(" & $i & ")"
      if $nType[0] == "range":
        return "L.isTable(" & $i & ")"

    if nType.kind == nnkPtrTy:
      return "(L.isLightUserData(" & $i & ") == 1)"

    if nType.kind == nnkSym:
      if $nType == "pointer":
        return "(L.isLightUserData(" & $i & ") == 1)"

  if mType.kind == nnkBracketExpr:
    if $mType[0] == "array":
      return "L.isTable(" & $i & ")"
    if $mType[0] == "set":
      return "L.isTable(" & $i & ")"
    if $mType[0] == "seq":
      return "L.isTable(" & $i & ")"
    if $mType[0] == "range":
      return "(L.isInteger(" & $i & ") == 1)"

  if mType.kind == nnkPtrTy:
    return "(L.isLightUserData(" & $i & ") == 1)"

  if mType.kind == nnkVarTy:
    let nType = getType(mType[0])
    if nType.kind in {nnkObjectTy, nnkRefTy}:
      return "(L.isUserData(" & $i & ") == 1)"
    if nType.kind == nnkSym:
      return genCheckType(nType, i, procName)

  if mType.kind == nnkEnumTy:
    return "(L.isInteger(" & $i & ") == 1)"

  error(procName & " : unknown param type: " & $mType.kind & "\n" & mType.treeRepr)
  result = ""

proc genCheckType(mType: NimNode, i: int, procName: string): string =
  case mType.kind:
  of nnkSym:
    result = genBasicCheck(mType, i, procName)
    if result == "": result = genComplexCheck(mType, i, procName)
  else:
    result = genComplexCheck(mType, i, procName)

#second level of ov proc resolution
proc genCheck(params: seq[argDesc], flags: ovFlags, procName: string): string {.compileTime.} =
  var glue = "    if "
  let start = if ovfUseObject in flags: 1 else: 0
  for i in start..params.len-1:
    glue.add genCheckType(params[i].mType, i + 1, procName)
    if i < params.len-1:
      glue.add " and "
    else:
      glue.add ":\n"
  result = glue

#overloaded proc need to be resolved by their params count and params type
#genCheck generate code to check params type
proc genOvCallMany(ctx: proxyDesc, ovp: seq[ovProcElem], procName: string, flags: ovFlags): string {.compileTime.} =
  var glue = ""
  for ov in ovp:
    glue.add genCheck(ov.params, flags, procName)
    glue.add genOvCallSingle(ctx, ov, procName, "    ", flags)
  result = glue

proc genOvCall(ctx: proxyDesc, ovp: seq[ovProc], procName: string, flags: ovFlags): string {.compileTime.} =
  let constructorMatter = if ovfConstructor in flags: " - 1" else: ""
  var glue = "  let numArgs = L.getTop().int$1\n" % [constructorMatter]
  for k in ovp:
    glue.add "  if numArgs == $1:\n" % [$k.numArgs] #first level of ov proc resolution
    if k.procs.len == 1:
      glue.add genOvCallSingle(ctx, k.procs[0], procName, "  ", flags)
    else:
      glue.add genOvCallMany(ctx, k.procs, procName, flags)
  result = glue

proc bindOverloadedFunction(ctx: proxyDesc, gp: seq[NimNode], ov: NimNode, glueProc, procName: string): string {.compileTime.} =
  var ovl = newSeq[ovProc]()

  for s in children(ov):
    let n = getImpl(s.symbol)
    if n.kind != nnkProcDef:
      error("bindObject: " & procName & " is not a proc")

    let params = n[3]
    let retType = replaceRet(params[0], gp, n[2])
    let argList = paramsToArgList(params, gp, n[2])
    ovl.addOvProc(retType, argList)

  var glue = "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add genOvCall(ctx, ovl, procName, {ovfUseRet})
  glue.add "  discard L.error(\"$1: invalid param count\")\n" % [procName]
  glue.add "  return 0\n"

  result = glue

#this proc is exported because of the NLBFunc macro expansion occured on bindFunction caller module
proc bindFunctionImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    libName = if ctx.libName.kind != nnkEmpty: $ctx.libName else: ""
    libKind = ctx.libName.kind
    arg = ctx.bindList
    exportLib = libName != "" and libName != "GLOBAL" or (libName == "GLOBAL" and libKind == nnkStrLit)

  gContext.setLen 0
  var glue = ""
  if exportLib:
    glue.add addMemberCap(SL, libName, arg.len)

  for i in 0..arg.len-1:
    let n = arg[i]
    if n.node.kind notin {nnkSym, nnkClosedSymChoice}:
      error("bindFunction: arg[" & $i & "] need symbol not " & $n.node.kind)

    let
      procName = getAccQuotedName(n.node, n.lhsKind)
      glueProc = "nimLUAproxy" & $proxyCount
      exportedName = n.name

    if n.node.kind == nnkSym:
      glue.add bindSingleFunction(ctx, n.genericParams, getImpl(n.node.symbol), glueProc, procName)
    else: #nnkClosedSymChoice
      glue.add bindOverloadedFunction(ctx, n.genericParams, n.node, glueProc, procName)

    if exportLib:
      glue.add "discard " & SL & ".pushString(\"" & exportedName & "\")\n"
      glue.add SL & ".pushCfunction(" & glueProc & ")\n"
      glue.add SL & ".setTable(-3)\n"
    else:
      glue.add SL & ".pushCfunction(" & glueProc & ")\n"
      glue.add SL & ".setGlobal(\"" & exportedName & "\")\n"

    inc proxyCount

  if exportLib:
    glue.add SL & ".setGlobal(\"" & libName & "\")\n"

  result = parseCode(gContext & glue)

#call this macro with following params pattern:
# * bindFunction(luaState, "libName", ident1, ident2, .., identN)
#     -> export nim function(s) with lua scope named "libName"
# * bindFunction(luaState, ident1, ident2, .., identN)
#     -> export nim function(s) to lua global scope

macro bindFunction*(arg: varargs[untyped]): stmt =
  result = genProxyMacro(arg, {nlbUSeLib, nlbRegisterClosure, nlbRegisterGeneric}, "Function")

macro bindProc*(arg: varargs[untyped]): stmt =
  result = genProxyMacro(arg, {nlbUSeLib, nlbRegisterClosure, nlbRegisterGeneric}, "Function")

# ----------------------------------------------------------------------
# ----------------------------- bindConst ------------------------------
# ----------------------------------------------------------------------

proc constructConstBasic(SL, name, indent: string, n: NimNode): string {.compileTime.} =
  if n.kind in {nnkCharLit..nnkUInt64Lit}:
    var nlb = indent & "when not internalTestForBOOL($1[0]):\n" % [name]
    nlb.add indent & "  $1.pushInteger(lua_Integer($2[i]))\n" % [SL, name]
    nlb.add indent & "else:\n"
    nlb.add indent & "  $1.pushBoolean($2[i].cint)\n" % [SL, name]
    return nlb

  if n.kind in {nnkFloatLit..nnkFloat64Lit}:
    return indent & "$1.pushNumber(lua_Number($2[i]))\n" % [SL, name]

  if n.kind in {nnkStrLit, nnkRStrLit, nnkTripleStrLit}:
    return indent & "discard $1.pushLString($2[i], $2[i].len)\n" % [SL, name]

  echo "C: ", treeRepr(n)
  result = ""

proc constructConstParBasic(SL, indent: string, n: NimNode, name: string, idx: int): string {.compileTime.} =
  if n.kind in {nnkCharLit..nnkUInt64Lit}:
    var nlb = indent & "when not internalTestForBOOL($2[0][0]):\n" % [SL, name]
    nlb.add indent & "  $1.pushInteger(lua_Integer($2[i][$3]))\n" % [SL, name, $idx]
    nlb.add indent & "else:\n"
    nlb.add indent & "  $1.pushBoolean($2[i][$3].cint)\n" % [SL, name, $idx]
    return nlb

  if n.kind in {nnkFloatLit..nnkFloat64Lit}:
    return indent & "$1.pushNumber(lua_Number($2[i][$3]))\n" % [SL, name, $idx]

  if n.kind in {nnkStrLit, nnkRStrLit, nnkTripleStrLit}:
    return indent & "discard $1.pushLString($2[i][$3], $2[i][$3].len)\n" % [SL, name, $idx]

  echo "B: ", treeRepr(n)
  result = ""

proc constructConstPar(SL, name, indent: string, n: NimNode): string {.compileTime.} =
  result = constructConstParBasic(SL, indent, n[0], name, 0)
  result.add constructConstParBasic(SL, indent, n[1], name, 1)

proc constructConst(SL: string, n: NimNode, name: string): string {.compileTime.} =
  if n.kind in {nnkCharLit..nnkUInt64Lit}:
    var nlb = "when not internalTestForBOOL($1):\n" % [name]
    nlb.add "  $1.pushInteger(lua_Integer($2))\n" % [SL, $(n.intVal)]
    nlb.add "else:\n"
    nlb.add "  $1.pushBoolean($2.cint)\n" % [SL, $(n.intVal)]
    return nlb

  if n.kind in {nnkFloatLit..nnkFloat64Lit}:
    return "$1.pushNumber(lua_Number($2))\n" % [SL, $(n.floatVal)]

  if n.kind in {nnkStrLit, nnkRStrLit, nnkTripleStrLit}:
    return "discard $1.pushLString(\"$2\", $3)\n" % [SL, n.strVal, $(n.strVal.len)]

  if n.kind == nnkBracket:
    if n[0].kind in {nnkCharLit..nnkTripleStrLit}:
      var nlb = "$1.createTable($2, 0)\n" % [SL, $n.len]
      nlb.add "for i in 0..$1:\n" % [$(n.len-1)]
      nlb.add constructConstBasic(SL, name, "  ", n[0])
      nlb.add "  $1.rawSeti(-2, i.cint)\n" % [SL]
      return nlb
    elif n[0].kind in {nnkPar}:
      if n[0].len == 2:
        var nlb = "$1.createTable(0, $2)\n" % [SL, $n.len]
        nlb.add "for i in 0..$1:\n" % [$(n.len-1)]
        nlb.add constructConstPar(SL, name, "  ", n[0])
        nlb.add "  $1.setTable(-3)\n" % [SL]
        return nlb

  echo "A: ", treeRepr(n)
  result = ""

proc bindConstImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    libName = if ctx.libName.kind != nnkEmpty: $ctx.libName else: ""
    libKind = ctx.libName.kind
    arg = ctx.bindList
    exportLib = libName != "" and libName != "GLOBAL" or (libName == "GLOBAL" and libKind == nnkStrLit)

  var glue = ""
  if exportLib:
    glue.add addMemberCap(SL, libName, arg.len)

  for i in 0..arg.len-1:
    let n = arg[i]
    if n.node.kind != nnkSym:
      error("bindConst: arg[" & $i & "] need symbol not " & $n.node.kind)

    let exportedName = n.name

    if exportLib:
      glue.add "discard " & SL & ".pushString(\"" & exportedName & "\")\n"
      glue.add constructConst(SL, getImpl(n.node.symbol), $n.node)
      glue.add SL & ".setTable(-3)\n"
    else:
      glue.add constructConst(SL, getImpl(n.node.symbol), $n.node)
      glue.add SL & ".setGlobal(\"" & exportedName & "\")\n"

  if exportLib:
    glue.add SL & ".setGlobal(\"" & libName & "\")\n"

  result = parseCode(glue)

macro bindConst*(arg: varargs[untyped]): stmt =
  result = genProxyMacro(arg, {nlbUseLib}, "Const")

# -----------------------------------------------------------------------
# ----------------------------- bindObject ------------------------------
# -----------------------------------------------------------------------

proc bindSingleConstructor(ctx: proxyDesc, gp: seq[NimNode], n, subject: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  if n.kind != nnkProcDef:
    error("bindFunction: " & procName & " is not a proc")

  let params = n[3]
  let retType = replaceRet(params[0], gp, n[2])

  if subject.kind != retType.kind and $subject != $retType:
    error("invalid constructor ret type")

  let argList = paramsToArgList(params, gp, n[2])

  var glue = "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & newUD(subjectName)
  #always zeroed the memory if you mix gc code and unmanaged code
  #otherwise, strange things will happened
  if isRefType(subject): glue.add "  zeroMem(proxy, sizeof(luaL_$1Proxy))\n" % [subjectName]
  glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfConstructor})
  if isRefType(subject): glue.add "  GC_ref(proxy.ud)\n"
  glue.add "  L.getMetatable(luaL_$1)\n" % [subjectName]
  glue.add "  discard L.setMetatable(-2)\n"
  glue.add "  result = 1\n"
  result = glue

proc eqType(a, b: NimNode): bool {.compileTime.} =
  if a.kind == nnkSym and b.kind == nnkVarTy:
    if sameType(a, b[0]): return true
  result = sameType(a, b)

proc bindOverloadedConstructor(ctx: proxyDesc, gp: seq[NimNode], ov, subject: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  var ovl = newSeq[ovProc]()

  for s in children(ov):
    let n = getImpl(s.symbol)
    if n.kind != nnkProcDef:
      error("bindObject: " & procName & " is not a proc")

    let params = n[3]
    let retType = replaceRet(params[0], gp, n[2])
    let argList = paramsToArgList(params, gp, n[2])

    #not a valid constructor
    if subject.kind != retType.kind and not eqType(subject, retType): continue
    ovl.addOvProc(retType, argList)

  var glue = "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = cast[ptr luaL_$1Proxy](L.newUserData(sizeof(luaL_$1Proxy)))\n" % [subjectName]
  #always zeroed the memory if you mix gc code and unmanaged code
  #otherwise, strange things will happened
  if isRefType(subject): glue.add "  zeroMem(proxy, sizeof(luaL_$1Proxy))\n" % [subjectName]
  glue.add genOvCall(ctx, ovl, procName, {ovfConstructor})
  if isRefType(subject): glue.add "  GC_ref(proxy.ud)\n"
  glue.add "  L.getMetatable(luaL_$1)\n" % [subjectName]
  glue.add "  discard L.setMetatable(-2)\n"
  glue.add "  result = 1\n"
  result = glue

proc bindObjectSingleMethod(ctx: proxyDesc, gp: seq[NimNode], n, subject: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  if n.kind != nnkProcDef:
    error("bindFunction: " & procName & " is not a proc")

  let params = n[3]
  let retType = replaceRet(params[0], gp, n[2])
  let argList = paramsToArgList(params, gp, n[2])

  if eqType(subject, retType):
    return bindSingleConstructor(ctx, gp, n, subject, glueProc, procName, subjectName)

  if argList.len == 0:
    error(procName & ": invalid object method")

  if not eqType(subject, argList[0].mType):
    error("object method need object type as first param: " & procName)

  var glue = "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & checkUD(subjectName, "1")
  glue.add genOvCallSingle(ctx, newProcElem(retType, argList), procName, "", {ovfUseObject, ovfUseRet})
  result = glue

proc bindObjectOverloadedMethod(ctx: proxyDesc, gp: seq[NimNode], ov, subject: NimNode, glueProc, procName, subjectName: string): string {.compileTime.} =
  var ovl = newSeq[ovProc]()
  var ovc = newNimNode(nnkClosedSymChoice)

  var glue = ""
  for s in children(ov):
    let n = getImpl(s.symbol)
    if n.kind != nnkProcDef:
      error("bindConstructor: " & procName & " is not a proc")

    let params = n[3]
    let retType = replaceRet(params[0], gp, n[2])
    let argList = paramsToArgList(params, gp, n[2])

    if eqType(subject, retType): #constructor like
      ovc.add s
      continue

    if argList.len == 0: continue #not a valid object method
    if not eqType(subject, argList[0].mType): continue
    ovl.addOvProc(retType, argList)

  if ovc.len > 0:
    glue.add bindOverloadedConstructor(ctx, gp, ovc, subject, glueProc, procName, subjectName)
    return glue

  glue.add "proc " & glueProc & "(L: PState): cint {.cdecl.} =\n"
  glue.add "  var proxy = " & checkUD(subjectName, "1")
  glue.add genOvCall(ctx, ovl, procName, {ovfUseObject, ovfUseRet})
  glue.add "  discard L.error(\"$1: invalid param count\")\n" % [procName]
  glue.add "  return 0\n"

  result = glue

proc bindObjectImpl*(ctx: proxyDesc): NimNode {.compileTime.} =
  let
    SL = ctx.luaCtx
    newName = $ctx.libName
    subject = ctx.subject
    arg = ctx.bindList

  gContext.setLen 0
  let subjectName = registerObject(subject)
  var glue = "discard $1.newMetatable(luaL_$2)\n" % [SL, subjectName]
  var regs = "var regs$1$2 = [\n" % [subjectName, $regsCount]

  for i in 0..arg.len-1:
    let n = arg[i]
    if n.node.kind notin {nnkSym, nnkClosedSymChoice}:
      error("bindObject: arg[" & $i & "] need symbol not " & $n.node.kind)

    let
      procName = getAccQuotedName(n.node, n.lhsKind)
      glueProc = "nimLUAproxy" & $proxyCount
      exportedName = if n.name == "constructor": "new" else: n.name

    regs.add "  luaL_Reg(name: \"$1\", fn: $2),\n" % [exportedName, glueProc]

    if n.node.kind == nnkSym:
      if n.name == "constructor" and n.lhsKind != nnkStrLit:
        glue.add bindSingleConstructor(ctx, n.genericParams, getImpl(n.node.symbol), subject, glueProc, procName, subjectName)
      else:
        glue.add bindObjectSingleMethod(ctx, n.genericParams, getImpl(n.node.symbol), subject, glueProc, procName, subjectName)
    else: #nnkClosedSymChoice
      if n.name == "constructor" and n.lhsKind != nnkStrLit:
        glue.add bindOverloadedConstructor(ctx, n.genericParams, n.node, subject, glueProc, procName, subjectName)
      else:
        glue.add bindObjectOverloadedMethod(ctx, n.genericParams, n.node, subject, glueProc, procName, subjectName)

    inc proxyCount

  if isRefType(subject) and not hasName("dtor" & $subject):
    glue.add "proc $1_destructor(L: PState): cint {.cdecl.} =\n" % [subjectName]
    glue.add "  var proxy = " & checkUD(subjectName, "1")
    glue.add "  GC_unref(proxy.ud)\n"
    regs.add "  luaL_Reg(name: \"__gc\", fn: $1_destructor),\n" % [subjectName]
    setName("dtor" & $subject)

  regs.add "  luaL_Reg(name: nil, fn: nil)\n"
  regs.add "]\n"

  glue.add regs
  glue.add "$1.setFuncs(cast[ptr luaL_reg](addr(regs$2$3)), 0)\n" % [SL, subjectName, $regsCount]
  glue.add "$1.pushValue(-1)\n" % [SL]
  glue.add "$1.setField(-1, \"__index\")\n" % [SL]
  glue.add "$1.setGlobal(\"$2\")\n" % [SL, newName]

  inc regsCount
  result = parseCode(gContext & glue)

macro bindObject*(arg: varargs[untyped]): stmt =
  result = genProxyMacro(arg, {nlbRegisterObject, nlbRegisterClosure, nlbRegisterGeneric}, "Object")
